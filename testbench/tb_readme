
The testbench for reads:
Drives read address signals on the manager side
ARADDR = 0xFFFFFFFF, ARVALID = 1 (master requests read)

Simulates the slaveâ€™s readiness by controlling ARREADY.

Scenarios tested:
1. Master asserts ARVALID while slave is not ready -> ARVALID = 1 ARREADY = 0. No handshake should occur.
2. Slave remains not ready for multiple cycles
3. Slave becomes ready
4. ARVALID deasserts after handshake

The testbench for writes:

1. Generates a 100 MHz clock and active-low reset (`ACLK`, `ARESETn`).
2. Instantiates the AXI4 interface:
   - `axi4_if #(.ADDR_W(32), .DATA_W(64), .ID_W(4)) axi_if(...)`
3. Instantiates the subordinate DUT:
   - `axi_subordinate dut(.s(axi_if.subordinate_mp));`
4. Drives the manager-side AXI write signals directly through the interface:
   - AW channel: `AWID`, `AWADDR`, `AWLEN`, `AWSIZE`, `AWBURST`, `AWVALID`
   - W channel: `WDATA`, `WSTRB`, `WLAST`, `WVALID`
   - B channel: `BREADY`
5. Observes slave responses:
   - `AWREADY`, `WREADY`, `BVALID`, `BID`, `BRESP`

#### Test Cases Implemented

- **Single-beat INCR write**  
  - `AWLEN = 0`, `AWSIZE = 3` (8 bytes/beat), `AWBURST = INCR`
  - Address within the 4 KB memory window.
  - `WSTRB = 8'hFF` (full-width write).
  - Expected `BRESP = OKAY (2'b00)`.

- **Multiple writes to different addresses**  
  - Checks that the subordinate can accept multiple independent write transactions.

